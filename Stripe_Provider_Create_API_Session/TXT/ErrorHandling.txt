- For every MicroService the error codes must be unique
- The first 2 digits represent the MicroService

Stripe-Provider-Service Clint Code: 40XXX, Server Code: 50XXX

While returning the code to you api, also return the ErrorCode & ErrorMessage With the HttpStatus

----------------------------------------------------------
Example:
- Success Response: POST PAYMENT
HttpStatus: 2XX
{
    "id": "12345",
{
    "id": "12345",
    "url": "https://example.com/resource/12345",
}
----------------------------------------------------------
- Failure Response:
HttpStatus: 4XX/5XX
{
    "errorCode": "50001",
    "errorMessage": "Internal Server Error"
}
----------------------------------------------------------

Error Handling: new Annotation : @ControllerAdvice
- Create a class GlobalExceptionHandler with @ControllerAdvice annotation

Steps:
01 Creata a class StripeProviderException extends RuntimeException
02 Create a class GlobalExceptionHandler with @ControllerAdvice annotation
03 Create a method to handle the exception with @ExceptionHandler annotation in the GlobalExceptionHandler class
04 Based on logic throw the exception

----------------------------------------------------------
Currently we have handled, StripeProviderException, so it's giving a proper errorCode & errorMessage. but accidentally other type of exceptions might be thrown from code.
If we don't handle it, then spring is default handling. and error response structure.

This multiple error response structure, will confuse the invoker. So we should standardize it. One consistent error response.

GENERIC EXCEPTION HANDLING :
- In the GlobalExceptionHandler class, create a method to handle generic exceptions with @ExceptionHandler(Exception.class) annotation
- This Class will handle all the exceptions which are not handled by specific exception handlers
- Anywhere in the code, if you can think, problem will happen, then you define errorCode , errorMessage & throw StripeProviderException
----------------------------------------------------------
For Representing a Constant in Java We use Enum
Error Code Enum:

public enum ErrorCode {
    INVALID_QUANTITY("40001", "Invalid quantity is provided"),
    INVALID_CURRENCY("40002", "Invalid currency is provided Currency = USD"),
    INTERNAL_SERVER_ERROR("50001", "Unable to process the request at this moment try again later");

    private final String errorCode;
    private final String errorMessage;

    ErrorCode(String errorCode, String errorMessage) {
        this.errorCode = errorCode;
        this.errorMessage = errorMessage;
    }
}
enum Help :
01 - Use to remove HardCoding in the code
02 - Use to represent a constant value
03 - Easy to maintain and more readable
----------------------------------------------------------
Common Layer Logic for Error Handling:
- No Response form Stripe PSP : Circuit Breaker Time-Out
- Throw Response If there are no response from PSP in given time :

ErrorCode: 50001
ErrorMessage: "No Response from PSP, Enable to Connect to Stripe PSP"

When One service Try to call another service
There Are 3 Possible Scenarios:
01 - Service is UP & Running : 200 OK
02 - Valid Fallback Response : 50X
03 - NO response from the service : TimeOut, Circuit Breaker

----------------------------------------------------------
In coding always think about the possible errors and handle them gracefully.
and also think about null scenarios.
----------------------------------------------------------
